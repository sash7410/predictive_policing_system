
==================================================
Content from: .DS_Store
==================================================

Error reading file .DS_Store: 'utf-8' codec can't decode byte 0x86 in position 23: invalid start byte

==================================================
Content from: requirements.txt
==================================================

# API and Data Processing
requests==2.31.0
python-dotenv==1.0.0
pandas==2.1.3

# Kafka
kafka-python==2.0.2

# Testing
pytest==7.4.3
pytest-cov==4.1.0

# Code Quality
black==23.12.0
pylint==3.0.3
mypy==1.7.1

# Logging and Error Handling
retry-requests==2.0.0

# Development Tools
setuptools>=65.5.1
wheel>=0.40.0
pip>=23.0.1

==================================================
Content from: README.md
==================================================

# Weather Service

A weather service that uses Kafka to process weather data requests from the Open-Meteo API.

## Installation

```bash
# Create and activate virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install package
pip install -e ".[dev]"
```

## Usage

1. Start Kafka using Docker:
```bash
docker-compose up -d
```

2. Run the consumer:
```bash
python scripts/start_consumer.py
```

3. In another terminal, run the producer:
```bash
python scripts/start_producer.py
```

## Configuration

Configuration can be set via environment variables in `.env` file:
- KAFKA_BOOTSTRAP_SERVERS: Kafka server address (default: localhost:9092)
- WEATHER_API_BASE_URL: OpenMeteo API URL
- LOG_LEVEL: Logging level (default: INFO)

==================================================
Content from: setup.py
==================================================

# setup.py

from setuptools import setup, find_packages

# Read README.md if it exists
try:
    with open("README.md", "r", encoding="utf-8") as fh:
        long_description = fh.read()
except FileNotFoundError:
    long_description = "A weather service using Kafka and OpenMeteo API"

setup(
    name="weather_service_v1",
    version="0.1.0",
    description="A weather service using Kafka and OpenMeteo API",
    long_description=long_description,
    long_description_content_type="text/markdown",
    author="Your Name",
    packages=find_packages(),
    install_requires=[
        'kafka-python>=2.0.2',
        'python-dotenv>=1.0.0',
        'requests>=2.31.0',
    ],
    extras_require={
        'dev': [
            'pytest>=7.4.0',
            'pytest-cov>=4.1.0',
            'black>=23.0.0',
            'pylint>=2.17.0',
            'mypy>=1.5.0',
        ],
    },
    python_requires='>=3.8',
    entry_points={
        'console_scripts': [
            'weather-producer=scripts.start_producer:main',
            'weather-consumer=scripts.start_consumer:main',
        ],
    },
)

==================================================
Content from: .env
==================================================

KAFKA_BOOTSTRAP_SERVERS=localhost:9092
WEATHER_API_BASE_URL=https://api.open-meteo.com/v1/forecast
KAFKA_WEATHER_REQUEST_TOPIC=weather_requests
KAFKA_WEATHER_RESULT_TOPIC=weather_results
LOG_LEVEL=INFO


==================================================
Content from: combiner.py
==================================================

import os
from pathlib import Path

# Define directories to ignore
IGNORE_DIRS = {
    '.venv',
    'venv',
    'env',
    'build',
    'dist',
    '__pycache__',
    'node_modules',
    '.git',
    '.idea',
    '.vscode',
    'weather_service_v1.egg-info',
    '.pytest_cache',
    'scripts'
}


def combine_files(directory_path, output_file='combined_output.txt'):
    """
    Recursively combines all files in the specified directory and its subdirectories into a single output file,
    completely skipping ignored directories.

    Args:
        directory_path (str): Path to the directory containing files to combine
        output_file (str): Name of the output file (default: 'combined_output.txt')
    """
    try:
        # Convert to Path object for better path handling
        directory = Path(directory_path)

        # Check if directory exists
        if not directory.is_dir():
            raise NotADirectoryError(f"'{directory_path}' is not a valid directory")

        # Track processed files count
        processed_files = 0
        skipped_dirs = set()

        # Create or overwrite the output file
        with open(directory / output_file, 'w', encoding='utf-8') as outfile:
            # Walk through directory structure manually to have better control
            for root_path in directory.iterdir():
                # Skip completely if it's in ignored directories
                if root_path.is_dir():
                    if root_path.name in IGNORE_DIRS or any(parent.name in IGNORE_DIRS for parent in root_path.parents):
                        skipped_dirs.add(root_path.name)
                        continue

                    # Process files in non-ignored directories
                    for file_path in root_path.rglob('*'):
                        if not file_path.is_file() or file_path.name == output_file:
                            continue

                        # Skip if any parent directory is in ignore list
                        if any(parent.name in IGNORE_DIRS for parent in file_path.parents):
                            continue

                        # Process the file
                        relative_path = file_path.relative_to(directory)

                        # Write filename and path as a header
                        outfile.write(f"\n{'=' * 50}\n")
                        outfile.write(f"Content from: {relative_path}\n")
                        outfile.write(f"{'=' * 50}\n\n")

                        try:
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                outfile.write(infile.read())
                                outfile.write('\n')
                            processed_files += 1
                        except Exception as e:
                            outfile.write(f"Error reading file {relative_path}: {str(e)}\n")

                # Process files in root directory
                elif root_path.is_file() and root_path.name != output_file:
                    relative_path = root_path.relative_to(directory)

                    # Write filename and path as a header
                    outfile.write(f"\n{'=' * 50}\n")
                    outfile.write(f"Content from: {relative_path}\n")
                    outfile.write(f"{'=' * 50}\n\n")

                    try:
                        with open(root_path, 'r', encoding='utf-8') as infile:
                            outfile.write(infile.read())
                            outfile.write('\n')
                        processed_files += 1
                    except Exception as e:
                        outfile.write(f"Error reading file {relative_path}: {str(e)}\n")

        print(f"Successfully combined {processed_files} files into {output_file}")
        print("Completely skipped directories:", ", ".join(sorted(skipped_dirs)))

    except Exception as e:
        print(f"An error occurred: {str(e)}")


# Example usage
if __name__ == "__main__":
    # Get directory path from user
    dir_path = "/Users/sashank/Downloads/docs/courseFall24/BigData/project/predictive_policing_system/weather_service"
    combine_files(dir_path)

==================================================
Content from: docker-compose.yml
==================================================

version: '3'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1

==================================================
Content from: weather_service.egg-info/PKG-INFO
==================================================

Metadata-Version: 2.1
Name: weather_service
Version: 0.1.0
Summary: A weather service using Kafka and OpenMeteo API
Author: Your Name
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: kafka-python>=2.0.2
Requires-Dist: python-dotenv>=1.0.0
Requires-Dist: requests>=2.31.0
Provides-Extra: dev
Requires-Dist: pytest>=7.4.0; extra == "dev"
Requires-Dist: pytest-cov>=4.1.0; extra == "dev"
Requires-Dist: black>=23.0.0; extra == "dev"
Requires-Dist: pylint>=2.17.0; extra == "dev"
Requires-Dist: mypy>=1.5.0; extra == "dev"

# Weather Service

A weather service that uses Kafka to process weather data requests from the Open-Meteo API.

## Installation

```bash
# Create and activate virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# Install package
pip install -e ".[dev]"
```

## Usage

1. Start Kafka using Docker:
```bash
docker-compose up -d
```

2. Run the consumer:
```bash
python scripts/start_consumer.py
```

3. In another terminal, run the producer:
```bash
python scripts/start_producer.py
```

## Configuration

Configuration can be set via environment variables in `.env` file:
- KAFKA_BOOTSTRAP_SERVERS: Kafka server address (default: localhost:9092)
- WEATHER_API_BASE_URL: OpenMeteo API URL
- LOG_LEVEL: Logging level (default: INFO)


==================================================
Content from: weather_service.egg-info/SOURCES.txt
==================================================

README.md
setup.py
weather_service/__init__.py
weather_service/config.py
weather_service/exceptions.py
weather_service/logger.py
weather_service.egg-info/PKG-INFO
weather_service.egg-info/SOURCES.txt
weather_service.egg-info/dependency_links.txt
weather_service.egg-info/entry_points.txt
weather_service.egg-info/requires.txt
weather_service.egg-info/top_level.txt
weather_service/api/__init__.py
weather_service/api/weather.py
weather_service/kafka/__init__.py
weather_service/kafka/consumer.py
weather_service/kafka/producer.py
weather_service/utils/__init__.py
weather_service/utils/time.py

==================================================
Content from: weather_service.egg-info/entry_points.txt
==================================================

[console_scripts]
weather-consumer = scripts.start_consumer:main
weather-producer = scripts.start_producer:main


==================================================
Content from: weather_service.egg-info/requires.txt
==================================================

kafka-python>=2.0.2
python-dotenv>=1.0.0
requests>=2.31.0

[dev]
pytest>=7.4.0
pytest-cov>=4.1.0
black>=23.0.0
pylint>=2.17.0
mypy>=1.5.0


==================================================
Content from: weather_service.egg-info/top_level.txt
==================================================

weather_service


==================================================
Content from: weather_service.egg-info/dependency_links.txt
==================================================




==================================================
Content from: test_weather_service.py
==================================================

# test_weather_service.py

from weather_service_v1.kafka.producer import WeatherProducer
from weather_service_v1 import setup_logger
import time

logger = setup_logger(__name__)


def test_weather_service():
    """Test the weather service with synchronous request-response"""
    producer = WeatherProducer()

    try:
        # Test multiple locations and times
        test_cases = [
            {
                'latitude': 40.87922,
                'longitude': -73.86106,
                'date': "2024-12-17",
                'time_str': "3:45 PM",
                'description': "New York"
            },
            {
                'latitude': 34.0522,
                'longitude': -118.2437,
                'date': "2024-12-17",
                'time_str': "2:30 PM",
                'description': "Los Angeles"
            }
        ]

        for case in test_cases:
            logger.info(f"\nTesting weather data for {case['description']}:")

            result = producer.get_weather_data(
                latitude=case['latitude'],
                longitude=case['longitude'],
                date=case['date'],
                time_str=case['time_str']
            )

            # Print the results
            logger.info(f"Location: {case['description']}")
            logger.info(f"Time: {result['time']}")
            logger.info(f"Temperature: {result['temperature']}°C")
            logger.info(f"Humidity: {result['relative_humidity']}%")
            logger.info(f"Wind Speed: {result['wind_speed_10m']} km/h")
            logger.info(f"Wind Direction: {result['wind_direction_10m (deg)']}°")
            logger.info("------------------------")

            # Small delay between requests
            time.sleep(1)

    except Exception as e:
        logger.error(f"Test failed: {e}")
    finally:
        producer.close()


if __name__ == "__main__":
    test_weather_service()

==================================================
Content from: weather_service/worker.py
==================================================

from kafka import KafkaConsumer, KafkaProducer
import json
import requests
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class WeatherWorker:
    def __init__(self, kafka_server='localhost:9092'):
        self.consumer = KafkaConsumer(
            'weather_requests',
            bootstrap_servers=[kafka_server],
            value_deserializer=lambda x: json.loads(x.decode('utf-8')),
            group_id='weather_workers'
        )

        self.producer = KafkaProducer(
            bootstrap_servers=[kafka_server],
            value_serializer=lambda v: json.dumps(v).encode('utf-8')
        )

    def fetch_weather(self, latitude: float, longitude: float, date: str, hour: int) -> dict:
        url = (
            f"https://api.open-meteo.com/v1/forecast?"
            f"latitude={latitude}&longitude={longitude}"
            f"&hourly=temperature_2m,relative_humidity_2m,rain,snowfall,snow_depth,"
            f"cloud_cover,wind_speed_10m,wind_direction_10m"
            f"&start_date={date}&end_date={date}"
        )

        response = requests.get(url)
        data = response.json()

        time_str = f"{date}T{hour:02d}:00"
        hour_index = data['hourly']['time'].index(time_str)

        return {
            'temperature': data['hourly']['temperature_2m'][hour_index],
            'humidity': data['hourly']['relative_humidity_2m'][hour_index],
            'rain': data['hourly']['rain'][hour_index],
            'wind_speed': data['hourly']['wind_speed_10m'][hour_index],
            'wind_direction': data['hourly']['wind_direction_10m'][hour_index]
        }

    def start(self):
        logger.info("Weather worker started...")
        try:
            for message in self.consumer:
                data = message.value
                request_id = data.get('request_id')
                try:
                    result = self.fetch_weather(
                        data['latitude'],
                        data['longitude'],
                        data['date'],
                        data['hour']
                    )
                    result['request_id'] = request_id
                    self.producer.send('weather_results', result)

                except Exception as e:
                    error_msg = {'error': str(e), 'request_id': request_id}
                    self.producer.send('weather_results', error_msg)
                self.producer.flush()
        finally:
            self.close()

    def close(self):
        self.consumer.close()
        self.producer.close()


if __name__ == "__main__":
    worker = WeatherWorker()
    worker.start()

==================================================
Content from: weather_service/service.py
==================================================

# weather_service/service.py

from kafka import KafkaProducer, KafkaConsumer
import json
import uuid
import time
import logging
from weather_service.utils import preprocess_time

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class WeatherService:
    def __init__(self, kafka_server='localhost:9092'):
        self.producer = KafkaProducer(
            bootstrap_servers=[kafka_server],
            value_serializer=lambda v: json.dumps(v).encode('utf-8')
        )

        self.consumer = KafkaConsumer(
            'weather_results',
            bootstrap_servers=[kafka_server],
            value_deserializer=lambda x: json.loads(x.decode('utf-8')),
            auto_offset_reset='earliest',
            group_id=f'weather_client_{uuid.uuid4()}',
            consumer_timeout_ms=1000
        )

    def get_weather(self, latitude: float, longitude: float, date: str, time_str: str,
                   timeout_seconds: int = 30) -> dict:
        request_id = str(uuid.uuid4())
        hour = preprocess_time(time_str)
        message = {
            'request_id': request_id,
            'latitude': latitude,
            'longitude': longitude,
            'date': date,
            'hour': hour
        }

        self.producer.send('weather_requests', message)
        self.producer.flush()

        start_time = time.time()
        while time.time() - start_time < timeout_seconds:
            try:
                for msg in self.consumer:
                    logger.info(f"Received message: {msg.value}")
                    if msg.value.get('request_id') == request_id:
                        if 'error' in msg.value:
                            raise Exception(msg.value['error'])
                        return msg.value
            except StopIteration:
                continue

        raise TimeoutError(f"No response received within {timeout_seconds} seconds")

    def close(self):
        self.producer.close()
        self.consumer.close()

==================================================
Content from: weather_service/test_weather.py
==================================================

from service import WeatherService


def main():
    weather = WeatherService()
    try:
        result = weather.get_weather(
            latitude=40.87922,
            longitude=-73.86106,
            date="2024-12-17",
            time_str="3:45 PM"
        )

        print("\nWeather Data:")
        print(f"Temperature: {result['temperature']}°C")
        print(f"Humidity: {result['humidity']}%")
        print(f"Rain: {result['rain']} mm")
        print(f"Wind Speed: {result['wind_speed']} km/h")
        print(f"Wind Direction: {result['wind_direction']}°")

    finally:
        weather.close()



if __name__ == "__main__":
    main()

==================================================
Content from: weather_service/__init__.py
==================================================



==================================================
Content from: weather_service/utils.py
==================================================

from datetime import datetime


def preprocess_time(time_str: str) -> int:
    """Convert time string to nearest hour"""
    try:
        # Try parsing with AM/PM
        try:
            dt = datetime.strptime(time_str.strip().lower(), "%I:%M %p")
        except ValueError:
            # Try parsing 24-hour format
            try:
                dt = datetime.strptime(time_str.strip(), "%H:%M")
            except ValueError:
                # Try parsing with AM/PM without space
                dt = datetime.strptime(time_str.strip().lower(), "%I:%M%p")

        # Convert to decimal hours and round to nearest hour
        decimal_hour = dt.hour + dt.minute / 60
        rounded_hour = round(decimal_hour)

        # Handle midnight case
        if rounded_hour == 24:
            rounded_hour = 0

        return rounded_hour

    except ValueError as e:
        raise ValueError("Invalid time format. Use '3:29 pm', '15:45', or '3:00 PM'") from e
